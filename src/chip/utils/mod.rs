mod lexer;
pub use lexer::Lexer;

mod character;
pub use character::Character;

mod position;
pub use position::Position;

mod token;
pub use token::{ Token, TokenType };

pub fn fontset()->[u8; 180]{
    return [
        0xf0, 0x90, 0x90, 0x90, 0xf0,   // 0
        0x20, 0x60, 0x20, 0x20, 0x70,   // 1
        0xf0, 0x10, 0xf0, 0x80, 0xf0,   // 2
        0xf0, 0x10, 0xf0, 0x10, 0xf0,   // 3
        0x90, 0x90, 0xf0, 0x10, 0x10,   // 4
        0xf0, 0x80, 0xf0, 0x10, 0xf0,   // 5
        0xf0, 0x80, 0xf0, 0x90, 0xf0,   // 6
        0xf0, 0x10, 0x20, 0x40, 0x40,   // 7
        0xf0, 0x90, 0xf0, 0x90, 0xf0,   // 8
        0xf0, 0x90, 0xf0, 0x10, 0xf0,   // 9
        0xf0, 0x90, 0xf0, 0x90, 0x90,   // A
        0xe0, 0x90, 0xe0, 0x90, 0xe0,   // B
        0xf0, 0x80, 0x80, 0x80, 0xf0,   // C
        0xe0, 0x90, 0x90, 0x90, 0xe0,   // D
        0xf0, 0x80, 0xf0, 0x80, 0xf0,   // E
        0xf0, 0x80, 0xf0, 0x80, 0x80,   // F

        // high-res mode font sprites (0-9)
        0x3C, 0x7E, 0xE7, 0xC3, 0xC3, 0xC3, 0xC3, 0xE7, 0x7E, 0x3C, 
        0x18, 0x38, 0x58, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C,
        0x3E, 0x7F, 0xC3, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xFF, 0xFF,
        0x3C, 0x7E, 0xC3, 0x03, 0x0E, 0x0E, 0x03, 0xC3, 0x7E, 0x3C,
        0x06, 0x0E, 0x1E, 0x36, 0x66, 0xC6, 0xFF, 0xFF, 0x06, 0x06,
        0xFF, 0xFF, 0xC0, 0xC0, 0xFC, 0xFE, 0x03, 0xC3, 0x7E, 0x3C,
        0x3E, 0x7C, 0xC0, 0xC0, 0xFC, 0xFE, 0xC3, 0xC3, 0x7E, 0x3C,
        0xFF, 0xFF, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x60, 0x60,
        0x3C, 0x7E, 0xC3, 0xC3, 0x7E, 0x7E, 0xC3, 0xC3, 0x7E, 0x3C,
        0x3C, 0x7E, 0xC3, 0xC3, 0x7F, 0x3F, 0x03, 0x03, 0x3E, 0x7C
    ];
}

pub fn hex(value: u16)->String{
    let mut init = value;
    let mut builder = String::new();
    while init > 0{
        let ch = format!("{}", init % 16);
        builder.insert_str(0, match ch.as_ref(){
            "10" => "A",
            "11" => "B",
            "12" => "C",
            "13" => "D",
            "14" => "E",
            "15" => "F",
            __ => ch.as_ref()
        });
        init /= 16;
    }
    return if builder.is_empty() { String::from("0") } else { builder };
}

pub fn from_hex(numb: &str)->u16{
    if numb.starts_with("0x") || numb.starts_with("0b"){
        let mut number: u16 = 0;
        for i in 2..numb.len(){
            let mut value = numb.chars().nth(i).unwrap() as u16;
            if value >= 65 && value <= 70{
                value -= 55;
            }else if value >= 97 && value <= 102{
                value -= 87;
            }else if value >= 48 && value <= 57{
                value -= 48;
            }
            number += value * u32::pow( if numb.contains("0x") { 16 } else { 2 }, (numb.len() - i - 1 ) as u32) as u16;
        }
        return number;   
    }
    return numb.parse().unwrap(); 
}

